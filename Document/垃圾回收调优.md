### 1 确定目标

#### 1.1【低延迟】还是【高吞吐量】，选择合适的回收器。

* CMS,G1,ZGC  适用于互联网项目，追求高响应。
* ParallelGC  适用于后台大量计算的场景

#### 1.2最快的GC是不发生GC

* 查看Fu山GC前后的内存占用，考虑下面几个问题

  * 数据是不是太多？ 

     resultSet=statement.executeQuery("select from limit n")

  * 数据表示是否太臃肿？
    ·对象图
    ·对象大小  Integer 24 int 4

  * 是否存在内存泄漏？

  ​        可以使用软引用，弱引用使得及时回收。或者引入第三方的缓存，不要再Java中缓存。

首先排除自己代码问题。然后调优建议先从新生代开始。

#### 1.3 新生代垃圾回收调优

* 新生代的特点
  * 所有的new操作的内存分配非常廉价且迅速。每一个线程都会在伊甸园中给它分配一个私有的区域,叫TLAB，每次new一个对象,会检查TLAB缓冲区中有没有该对象,如果有,会优先在这个区域里面进行对象内存分配!  
  
    **为什么要有这个东西?**?
    	对象分配其实也会有线程安全问题.线程1要该对象,在没分配完的时候线程2也要这个对象....会有线程安全问题。TLAB thread-local allocation buffer，每个线程用自己这块私有的内存来进行对象分配。
  
  * 死亡对象的回收代价是零。复制算法，一次回收后Eden区和From Survivor 区为空。
  
  * 大部分对象用过即死。使得绝大部分对象都可以在垃圾回收中进行回收，少部分存活。
  
  * Minor GC的时间远远低于Full GC
  
* Oracle建议新生代的内存占整个堆的**25%-50%**...

* 新生代能容纳所有【**并发量*（请求-响应）**】的数据

* 幸存区大到能保留【当前活跃对象+需要晋升对象】。避免导致提前晋升的对象在FullGC的时候才能回收(本来不晋升在新生代就可以回收了。)

* 晋升阈值配置得当，让长时间存活对象尽快晋升。不然会在新生代中每次gc的时候复制来复制去,效率很低。

```properties
-XX:MaxTenuringThreshold=threshold #最大晋升阈值
-XX:+PrintTenuringDistribution
```

#### 1.4老年代调优

以CMIS为例

* CMS的老年代内存越大越好

* 先尝试不做调优，如果没有FullGC那么已经，否则先尝试调优新生代

* 观察发生FullGC时老年代内存占用，将老年代内存预设调大1/4~1/3

  ```properties
  -XX:CMSInitiatingOccupancyFraction=percent  #控制老年代垃圾占比达到多少时及逆行垃圾回收。
  ```

  

案例1**Full GC和Minor GC频繁**

(1)先从新生代调优开始...调大新生代内存.避免新生代晋升过快以及频繁Minor GC。

案例2**请求高峰期发生FullGC,单次暂停时间特别长(CMS)**

重新标记阶段需要遍历新生代和老年代，花费时间较长。可以在重新标记前就先进行一次新生代的垃圾回收，减少新生代对象的数量。

```properties
-XX:+CMSScavengeBeforeRemark
```

