### 6.运行期优化

#### 6.1 即时编译

```java
public class JIT1 {

    // -XX:+PrintCompilation -XX:-DoEscapeAnalysis
    public static void main(String[] args) {
        for (int i = 0; i < 200; i++) {
            long start = System.nanoTime();
            for (int j = 0; j < 1000; j++) {
                new Object();
            }
            long end = System.nanoTime();
            System.out.printf("%d\t%d\n",i,(end - start));
        }
    }
}
```

刚开始创建100个对象时间耗时：

```
0 96426
1 52907
2 44800 
3 119040
--到了136次之后
136 853
137 853
138 853
```

原因是什么呢？ 

JVM 将执行状态分成了 5 个层次： 

* 0 层，解释执行（Interpreter） 

* 1 层，使用 C1 即时编译器编译执行（不带 profiling） 

* 2 层，使用 C1 即时编译器编译执行（带基本的 profiling） 

* 3 层，使用 C1 即时编译器编译执行（带完全的 profiling） 

* 4 层，使用 C2 即时编译器编译执行  

profiling 是指在运行过程中收集一些程序执行状态的数据，例如【方法的调用次数】，【循环的 回边次数】等

 即时编译器（JIT）与解释器的区别 

* 解释器是将字节码解释为机器码，下次即使遇到相同的字节码，仍会执行重复的解释 

* JIT 是将一些字节码编译为机器码，并存入 Code Cache，下次遇到相同的代码，直接执行，无需 再编译 

* 解释器是将字节码解释为针对所有平台都通用的机器码 

* JIT 会根据平台类型，生成平台特定的机器码 

对于占据大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运 行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速 度。 执行效率上简单比较一下 Interpreter < C1 < C2，总的目标是发现热点代码（hotspot名称的由来）. 

刚才的一种优化手段称之为【逃逸分析】，发现新建的对象只在循环内部，没有逃逸，所以可能实际执行的时候就没有在创建对象了。可以使用 -XX:- DoEscapeAnalysis 关闭逃逸分析，再运行刚才的示例观察结果

